var $f4ae831c35f9823dfa1c51403eec00$exports = {};

/* Dependencies. */
var $f4ae831c35f9823dfa1c51403eec00$var$extend = $parcel$require("64f4ae831c35f9823dfa1c51403eec00", "extend");
var $f4ae831c35f9823dfa1c51403eec00$var$bail = $parcel$require("64f4ae831c35f9823dfa1c51403eec00", "bail");
var $f4ae831c35f9823dfa1c51403eec00$var$vfile = $parcel$require("64f4ae831c35f9823dfa1c51403eec00", "vfile");
var $f4ae831c35f9823dfa1c51403eec00$var$trough = $parcel$require("64f4ae831c35f9823dfa1c51403eec00", "trough");
var $f4ae831c35f9823dfa1c51403eec00$var$string = $parcel$require("64f4ae831c35f9823dfa1c51403eec00", "x-is-string");
var $f4ae831c35f9823dfa1c51403eec00$var$plain = $parcel$require("64f4ae831c35f9823dfa1c51403eec00", "is-plain-obj");
/* Expose a frozen processor. */

$f4ae831c35f9823dfa1c51403eec00$exports = $f4ae831c35f9823dfa1c51403eec00$var$unified().freeze();
var $f4ae831c35f9823dfa1c51403eec00$var$slice = [].slice;
var $f4ae831c35f9823dfa1c51403eec00$var$own = {}.hasOwnProperty;
/* Process pipeline. */

var $f4ae831c35f9823dfa1c51403eec00$var$pipeline = $f4ae831c35f9823dfa1c51403eec00$var$trough().use($f4ae831c35f9823dfa1c51403eec00$var$pipelineParse).use($f4ae831c35f9823dfa1c51403eec00$var$pipelineRun).use($f4ae831c35f9823dfa1c51403eec00$var$pipelineStringify);

function $f4ae831c35f9823dfa1c51403eec00$var$pipelineParse(p, ctx) {
  ctx.tree = p.parse(ctx.file);
}

function $f4ae831c35f9823dfa1c51403eec00$var$pipelineRun(p, ctx, next) {
  p.run(ctx.tree, ctx.file, done);

  function done(err, tree, file) {
    if (err) {
      next(err);
    } else {
      ctx.tree = tree;
      ctx.file = file;
      next();
    }
  }
}

function $f4ae831c35f9823dfa1c51403eec00$var$pipelineStringify(p, ctx) {
  ctx.file.contents = p.stringify(ctx.tree, ctx.file);
}
/* Function to create the first processor. */


function $f4ae831c35f9823dfa1c51403eec00$var$unified() {
  var attachers = [];
  var transformers = $f4ae831c35f9823dfa1c51403eec00$var$trough();
  var namespace = {};
  var frozen = false;
  var freezeIndex = -1;
  /* Data management. */

  processor.data = data;
  /* Lock. */

  processor.freeze = freeze;
  /* Plug-ins. */

  processor.attachers = attachers;
  processor.use = use;
  /* API. */

  processor.parse = parse;
  processor.stringify = stringify;
  processor.run = run;
  processor.runSync = runSync;
  processor.process = process;
  processor.processSync = processSync;
  /* Expose. */

  return processor;
  /* Create a new processor based on the processor
   * in the current scope. */

  function processor() {
    var destination = $f4ae831c35f9823dfa1c51403eec00$var$unified();
    var length = attachers.length;
    var index = -1;

    while (++index < length) {
      destination.use.apply(null, attachers[index]);
    }

    destination.data($f4ae831c35f9823dfa1c51403eec00$var$extend(true, {}, namespace));
    return destination;
  }
  /* Freeze: used to signal a processor that has finished
   * configuration.
   *
   * For example, take unified itself.  Itâ€™s frozen.
   * Plug-ins should not be added to it.  Rather, it should
   * be extended, by invoking it, before modifying it.
   *
   * In essence, always invoke this when exporting a
   * processor. */


  function freeze() {
    var values;
    var plugin;
    var options;
    var transformer;

    if (frozen) {
      return processor;
    }

    while (++freezeIndex < attachers.length) {
      values = attachers[freezeIndex];
      plugin = values[0];
      options = values[1];
      transformer = null;

      if (options === false) {
        continue;
      }

      if (options === true) {
        values[1] = undefined;
      }

      transformer = plugin.apply(processor, values.slice(1));

      if (typeof transformer === 'function') {
        transformers.use(transformer);
      }
    }

    frozen = true;
    freezeIndex = Infinity;
    return processor;
  }
  /* Data management.
   * Getter / setter for processor-specific informtion. */


  function data(key, value) {
    if ($f4ae831c35f9823dfa1c51403eec00$var$string(key)) {
      /* Set `key`. */
      if (arguments.length === 2) {
        $f4ae831c35f9823dfa1c51403eec00$var$assertUnfrozen('data', frozen);
        namespace[key] = value;
        return processor;
      }
      /* Get `key`. */


      return $f4ae831c35f9823dfa1c51403eec00$var$own.call(namespace, key) && namespace[key] || null;
    }
    /* Set space. */


    if (key) {
      $f4ae831c35f9823dfa1c51403eec00$var$assertUnfrozen('data', frozen);
      namespace = key;
      return processor;
    }
    /* Get space. */


    return namespace;
  }
  /* Plug-in management.
   *
   * Pass it:
   * *   an attacher and options,
   * *   a preset,
   * *   a list of presets, attachers, and arguments (list
   *     of attachers and options). */


  function use(value) {
    var settings;
    $f4ae831c35f9823dfa1c51403eec00$var$assertUnfrozen('use', frozen);

    if (value === null || value === undefined) {
      /* Empty */
    } else if (typeof value === 'function') {
      addPlugin.apply(null, arguments);
    } else if (typeof value === 'object') {
      if ('length' in value) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new Error('Expected usable value, not `' + value + '`');
    }

    if (settings) {
      namespace.settings = $f4ae831c35f9823dfa1c51403eec00$var$extend(namespace.settings || {}, settings);
    }

    return processor;

    function addPreset(result) {
      addList(result.plugins);

      if (result.settings) {
        settings = $f4ae831c35f9823dfa1c51403eec00$var$extend(settings || {}, result.settings);
      }
    }

    function add(value) {
      if (typeof value === 'function') {
        addPlugin(value);
      } else if (typeof value === 'object') {
        if ('length' in value) {
          addPlugin.apply(null, value);
        } else {
          addPreset(value);
        }
      } else {
        throw new Error('Expected usable value, not `' + value + '`');
      }
    }

    function addList(plugins) {
      var length;
      var index;

      if (plugins === null || plugins === undefined) {
        /* Empty */
      } else if (typeof plugins === 'object' && 'length' in plugins) {
        length = plugins.length;
        index = -1;

        while (++index < length) {
          add(plugins[index]);
        }
      } else {
        throw new Error('Expected a list of plugins, not `' + plugins + '`');
      }
    }

    function addPlugin(plugin, value) {
      var entry = find(plugin);

      if (entry) {
        if ($f4ae831c35f9823dfa1c51403eec00$var$plain(entry[1]) && $f4ae831c35f9823dfa1c51403eec00$var$plain(value)) {
          value = $f4ae831c35f9823dfa1c51403eec00$var$extend(entry[1], value);
        }

        entry[1] = value;
      } else {
        attachers.push($f4ae831c35f9823dfa1c51403eec00$var$slice.call(arguments));
      }
    }
  }

  function find(plugin) {
    var length = attachers.length;
    var index = -1;
    var entry;

    while (++index < length) {
      entry = attachers[index];

      if (entry[0] === plugin) {
        return entry;
      }
    }
  }
  /* Parse a file (in string or VFile representation)
   * into a Unist node using the `Parser` on the
   * processor. */


  function parse(doc) {
    var file = $f4ae831c35f9823dfa1c51403eec00$var$vfile(doc);
    var Parser;
    freeze();
    Parser = processor.Parser;
    $f4ae831c35f9823dfa1c51403eec00$var$assertParser('parse', Parser);

    if ($f4ae831c35f9823dfa1c51403eec00$var$newable(Parser)) {
      return new Parser(String(file), file).parse();
    }

    return Parser(String(file), file); // eslint-disable-line new-cap
  }
  /* Run transforms on a Unist node representation of a file
   * (in string or VFile representation), async. */


  function run(node, file, cb) {
    $f4ae831c35f9823dfa1c51403eec00$var$assertNode(node);
    freeze();

    if (!cb && typeof file === 'function') {
      cb = file;
      file = null;
    }

    if (!cb) {
      return new Promise(executor);
    }

    executor(null, cb);

    function executor(resolve, reject) {
      transformers.run(node, $f4ae831c35f9823dfa1c51403eec00$var$vfile(file), done);

      function done(err, tree, file) {
        tree = tree || node;

        if (err) {
          reject(err);
        } else if (resolve) {
          resolve(tree);
        } else {
          cb(null, tree, file);
        }
      }
    }
  }
  /* Run transforms on a Unist node representation of a file
   * (in string or VFile representation), sync. */


  function runSync(node, file) {
    var complete = false;
    var result;
    run(node, file, done);
    $f4ae831c35f9823dfa1c51403eec00$var$assertDone('runSync', 'run', complete);
    return result;

    function done(err, tree) {
      complete = true;
      $f4ae831c35f9823dfa1c51403eec00$var$bail(err);
      result = tree;
    }
  }
  /* Stringify a Unist node representation of a file
   * (in string or VFile representation) into a string
   * using the `Compiler` on the processor. */


  function stringify(node, doc) {
    var file = $f4ae831c35f9823dfa1c51403eec00$var$vfile(doc);
    var Compiler;
    freeze();
    Compiler = processor.Compiler;
    $f4ae831c35f9823dfa1c51403eec00$var$assertCompiler('stringify', Compiler);
    $f4ae831c35f9823dfa1c51403eec00$var$assertNode(node);

    if ($f4ae831c35f9823dfa1c51403eec00$var$newable(Compiler)) {
      return new Compiler(node, file).compile();
    }

    return Compiler(node, file); // eslint-disable-line new-cap
  }
  /* Parse a file (in string or VFile representation)
   * into a Unist node using the `Parser` on the processor,
   * then run transforms on that node, and compile the
   * resulting node using the `Compiler` on the processor,
   * and store that result on the VFile. */


  function process(doc, cb) {
    freeze();
    $f4ae831c35f9823dfa1c51403eec00$var$assertParser('process', processor.Parser);
    $f4ae831c35f9823dfa1c51403eec00$var$assertCompiler('process', processor.Compiler);

    if (!cb) {
      return new Promise(executor);
    }

    executor(null, cb);

    function executor(resolve, reject) {
      var file = $f4ae831c35f9823dfa1c51403eec00$var$vfile(doc);
      $f4ae831c35f9823dfa1c51403eec00$var$pipeline.run(processor, {
        file: file
      }, done);

      function done(err) {
        if (err) {
          reject(err);
        } else if (resolve) {
          resolve(file);
        } else {
          cb(null, file);
        }
      }
    }
  }
  /* Process the given document (in string or VFile
   * representation), sync. */


  function processSync(doc) {
    var complete = false;
    var file;
    freeze();
    $f4ae831c35f9823dfa1c51403eec00$var$assertParser('processSync', processor.Parser);
    $f4ae831c35f9823dfa1c51403eec00$var$assertCompiler('processSync', processor.Compiler);
    file = $f4ae831c35f9823dfa1c51403eec00$var$vfile(doc);
    process(file, done);
    $f4ae831c35f9823dfa1c51403eec00$var$assertDone('processSync', 'process', complete);
    return file;

    function done(err) {
      complete = true;
      $f4ae831c35f9823dfa1c51403eec00$var$bail(err);
    }
  }
}
/* Check if `func` is a constructor. */


function $f4ae831c35f9823dfa1c51403eec00$var$newable(value) {
  return typeof value === 'function' && $f4ae831c35f9823dfa1c51403eec00$var$keys(value.prototype);
}
/* Check if `value` is an object with keys. */


function $f4ae831c35f9823dfa1c51403eec00$var$keys(value) {
  var key;

  for (key in value) {
    return true;
  }

  return false;
}
/* Assert a parser is available. */


function $f4ae831c35f9823dfa1c51403eec00$var$assertParser(name, Parser) {
  if (typeof Parser !== 'function') {
    throw new Error('Cannot `' + name + '` without `Parser`');
  }
}
/* Assert a compiler is available. */


function $f4ae831c35f9823dfa1c51403eec00$var$assertCompiler(name, Compiler) {
  if (typeof Compiler !== 'function') {
    throw new Error('Cannot `' + name + '` without `Compiler`');
  }
}
/* Assert the processor is not frozen. */


function $f4ae831c35f9823dfa1c51403eec00$var$assertUnfrozen(name, frozen) {
  if (frozen) {
    throw new Error(['Cannot invoke `' + name + '` on a frozen processor.\nCreate a new ', 'processor first, by invoking it: use `processor()` instead of ', '`processor`.'].join(''));
  }
}
/* Assert `node` is a Unist node. */


function $f4ae831c35f9823dfa1c51403eec00$var$assertNode(node) {
  if (!node || !$f4ae831c35f9823dfa1c51403eec00$var$string(node.type)) {
    throw new Error('Expected node, got `' + node + '`');
  }
}
/* Assert that `complete` is `true`. */


function $f4ae831c35f9823dfa1c51403eec00$var$assertDone(name, asyncName, complete) {
  if (!complete) {
    throw new Error('`' + name + '` finished async. Use `' + asyncName + '` instead');
  }
}