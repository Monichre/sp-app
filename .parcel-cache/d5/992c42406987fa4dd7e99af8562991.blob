var $a993e2d3ab65833ab45996fadcddf89$exports = {};
var $a993e2d3ab65833ab45996fadcddf89$var$parser = $parcel$require("8a993e2d3ab65833ab45996fadcddf89", "graphql/language/parser");
var $a993e2d3ab65833ab45996fadcddf89$var$parse = $a993e2d3ab65833ab45996fadcddf89$var$parser.parse; // Strip insignificant whitespace
// Note that this could do a lot more, such as reorder fields etc.

function $a993e2d3ab65833ab45996fadcddf89$var$normalize(string) {
  return string.replace(/[\s,]+/g, ' ').trim();
} // A map docString -> graphql document


var $a993e2d3ab65833ab45996fadcddf89$var$docCache = {}; // A map fragmentName -> [normalized source]

var $a993e2d3ab65833ab45996fadcddf89$var$fragmentSourceMap = {};

function $a993e2d3ab65833ab45996fadcddf89$var$cacheKeyFromLoc(loc) {
  return $a993e2d3ab65833ab45996fadcddf89$var$normalize(loc.source.body.substring(loc.start, loc.end));
} // For testing.


function $a993e2d3ab65833ab45996fadcddf89$var$resetCaches() {
  $a993e2d3ab65833ab45996fadcddf89$var$docCache = {};
  $a993e2d3ab65833ab45996fadcddf89$var$fragmentSourceMap = {};
} // Take a unstripped parsed document (query/mutation or even fragment), and
// check all fragment definitions, checking for name->source uniqueness.
// We also want to make sure only unique fragments exist in the document.


var $a993e2d3ab65833ab45996fadcddf89$var$printFragmentWarnings = true;

function $a993e2d3ab65833ab45996fadcddf89$var$processFragments(ast) {
  var astFragmentMap = {};
  var definitions = [];

  for (var i = 0; i < ast.definitions.length; i++) {
    var fragmentDefinition = ast.definitions[i];

    if (fragmentDefinition.kind === 'FragmentDefinition') {
      var fragmentName = fragmentDefinition.name.value;
      var sourceKey = $a993e2d3ab65833ab45996fadcddf89$var$cacheKeyFromLoc(fragmentDefinition.loc); // We know something about this fragment

      if ($a993e2d3ab65833ab45996fadcddf89$var$fragmentSourceMap.hasOwnProperty(fragmentName) && !$a993e2d3ab65833ab45996fadcddf89$var$fragmentSourceMap[fragmentName][sourceKey]) {
        // this is a problem because the app developer is trying to register another fragment with
        // the same name as one previously registered. So, we tell them about it.
        if ($a993e2d3ab65833ab45996fadcddf89$var$printFragmentWarnings) {
          console.warn("Warning: fragment with name " + fragmentName + " already exists.\n" + "graphql-tag enforces all fragment names across your application to be unique; read more about\n" + "this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
        }

        $a993e2d3ab65833ab45996fadcddf89$var$fragmentSourceMap[fragmentName][sourceKey] = true;
      } else if (!$a993e2d3ab65833ab45996fadcddf89$var$fragmentSourceMap.hasOwnProperty(fragmentName)) {
        $a993e2d3ab65833ab45996fadcddf89$var$fragmentSourceMap[fragmentName] = {};
        $a993e2d3ab65833ab45996fadcddf89$var$fragmentSourceMap[fragmentName][sourceKey] = true;
      }

      if (!astFragmentMap[sourceKey]) {
        astFragmentMap[sourceKey] = true;
        definitions.push(fragmentDefinition);
      }
    } else {
      definitions.push(fragmentDefinition);
    }
  }

  ast.definitions = definitions;
  return ast;
}

function $a993e2d3ab65833ab45996fadcddf89$var$disableFragmentWarnings() {
  $a993e2d3ab65833ab45996fadcddf89$var$printFragmentWarnings = false;
}

function $a993e2d3ab65833ab45996fadcddf89$var$stripLoc(doc, removeLocAtThisLevel) {
  var docType = Object.prototype.toString.call(doc);

  if (docType === '[object Array]') {
    return doc.map(function (d) {
      return $a993e2d3ab65833ab45996fadcddf89$var$stripLoc(d, removeLocAtThisLevel);
    });
  }

  if (docType !== '[object Object]') {
    throw new Error('Unexpected input.');
  } // We don't want to remove the root loc field so we can use it
  // for fragment substitution (see below)


  if (removeLocAtThisLevel && doc.loc) {
    delete doc.loc;
  } // https://github.com/apollographql/graphql-tag/issues/40


  if (doc.loc) {
    delete doc.loc.startToken;
    delete doc.loc.endToken;
  }

  var keys = Object.keys(doc);
  var key;
  var value;
  var valueType;

  for (key in keys) {
    if (keys.hasOwnProperty(key)) {
      value = doc[keys[key]];
      valueType = Object.prototype.toString.call(value);

      if (valueType === '[object Object]' || valueType === '[object Array]') {
        doc[keys[key]] = $a993e2d3ab65833ab45996fadcddf89$var$stripLoc(value, true);
      }
    }
  }

  return doc;
}

var $a993e2d3ab65833ab45996fadcddf89$var$experimentalFragmentVariables = false;

function $a993e2d3ab65833ab45996fadcddf89$var$parseDocument(doc) {
  var cacheKey = $a993e2d3ab65833ab45996fadcddf89$var$normalize(doc);

  if ($a993e2d3ab65833ab45996fadcddf89$var$docCache[cacheKey]) {
    return $a993e2d3ab65833ab45996fadcddf89$var$docCache[cacheKey];
  }

  var parsed = $a993e2d3ab65833ab45996fadcddf89$var$parse(doc, {
    experimentalFragmentVariables: $a993e2d3ab65833ab45996fadcddf89$var$experimentalFragmentVariables
  });

  if (!parsed || parsed.kind !== 'Document') {
    throw new Error('Not a valid GraphQL document.');
  } // check that all "new" fragments inside the documents are consistent with
  // existing fragments of the same name


  parsed = $a993e2d3ab65833ab45996fadcddf89$var$processFragments(parsed);
  parsed = $a993e2d3ab65833ab45996fadcddf89$var$stripLoc(parsed, false);
  $a993e2d3ab65833ab45996fadcddf89$var$docCache[cacheKey] = parsed;
  return parsed;
}

function $a993e2d3ab65833ab45996fadcddf89$var$enableExperimentalFragmentVariables() {
  $a993e2d3ab65833ab45996fadcddf89$var$experimentalFragmentVariables = true;
}

function $a993e2d3ab65833ab45996fadcddf89$var$disableExperimentalFragmentVariables() {
  $a993e2d3ab65833ab45996fadcddf89$var$experimentalFragmentVariables = false;
} // XXX This should eventually disallow arbitrary string interpolation, like Relay does


function $a993e2d3ab65833ab45996fadcddf89$var$gql()
/* arguments */
{
  var args = Array.prototype.slice.call(arguments);
  var literals = args[0]; // We always get literals[0] and then matching post literals for each arg given

  var result = typeof literals === "string" ? literals : literals[0];

  for (var i = 1; i < args.length; i++) {
    if (args[i] && args[i].kind && args[i].kind === 'Document') {
      result += args[i].loc.source.body;
    } else {
      result += args[i];
    }

    result += literals[i];
  }

  return $a993e2d3ab65833ab45996fadcddf89$var$parseDocument(result);
} // Support typescript, which isn't as nice as Babel about default exports


$a993e2d3ab65833ab45996fadcddf89$var$gql.default = $a993e2d3ab65833ab45996fadcddf89$var$gql;
$a993e2d3ab65833ab45996fadcddf89$var$gql.resetCaches = $a993e2d3ab65833ab45996fadcddf89$var$resetCaches;
$a993e2d3ab65833ab45996fadcddf89$var$gql.disableFragmentWarnings = $a993e2d3ab65833ab45996fadcddf89$var$disableFragmentWarnings;
$a993e2d3ab65833ab45996fadcddf89$var$gql.enableExperimentalFragmentVariables = $a993e2d3ab65833ab45996fadcddf89$var$enableExperimentalFragmentVariables;
$a993e2d3ab65833ab45996fadcddf89$var$gql.disableExperimentalFragmentVariables = $a993e2d3ab65833ab45996fadcddf89$var$disableExperimentalFragmentVariables;
$a993e2d3ab65833ab45996fadcddf89$exports = $a993e2d3ab65833ab45996fadcddf89$var$gql;