var $ddeaaa485da5b3088f0d01dfac5c39b5$exports = {};
$ddeaaa485da5b3088f0d01dfac5c39b5$exports = $ddeaaa485da5b3088f0d01dfac5c39b5$var$setextHeading;
var $ddeaaa485da5b3088f0d01dfac5c39b5$var$C_NEWLINE = '\n';
var $ddeaaa485da5b3088f0d01dfac5c39b5$var$C_TAB = '\t';
var $ddeaaa485da5b3088f0d01dfac5c39b5$var$C_SPACE = ' ';
var $ddeaaa485da5b3088f0d01dfac5c39b5$var$C_EQUALS = '=';
var $ddeaaa485da5b3088f0d01dfac5c39b5$var$C_DASH = '-';
var $ddeaaa485da5b3088f0d01dfac5c39b5$var$MAX_HEADING_INDENT = 3;
/* Map of characters which can be used to mark setext
 * headers, mapping to their corresponding depth. */

var $ddeaaa485da5b3088f0d01dfac5c39b5$var$SETEXT_MARKERS = {};
$ddeaaa485da5b3088f0d01dfac5c39b5$var$SETEXT_MARKERS[$ddeaaa485da5b3088f0d01dfac5c39b5$var$C_EQUALS] = 1;
$ddeaaa485da5b3088f0d01dfac5c39b5$var$SETEXT_MARKERS[$ddeaaa485da5b3088f0d01dfac5c39b5$var$C_DASH] = 2;

function $ddeaaa485da5b3088f0d01dfac5c39b5$var$setextHeading(eat, value, silent) {
  var self = this;
  var now = eat.now();
  var length = value.length;
  var index = -1;
  var subvalue = '';
  var content;
  var queue;
  var character;
  var marker;
  var depth;
  /* Eat initial indentation. */

  while (++index < length) {
    character = value.charAt(index);

    if (character !== $ddeaaa485da5b3088f0d01dfac5c39b5$var$C_SPACE || index >= $ddeaaa485da5b3088f0d01dfac5c39b5$var$MAX_HEADING_INDENT) {
      index--;
      break;
    }

    subvalue += character;
  }
  /* Eat content. */


  content = '';
  queue = '';

  while (++index < length) {
    character = value.charAt(index);

    if (character === $ddeaaa485da5b3088f0d01dfac5c39b5$var$C_NEWLINE) {
      index--;
      break;
    }

    if (character === $ddeaaa485da5b3088f0d01dfac5c39b5$var$C_SPACE || character === $ddeaaa485da5b3088f0d01dfac5c39b5$var$C_TAB) {
      queue += character;
    } else {
      content += queue + character;
      queue = '';
    }
  }

  now.column += subvalue.length;
  now.offset += subvalue.length;
  subvalue += content + queue;
  /* Ensure the content is followed by a newline and a
   * valid marker. */

  character = value.charAt(++index);
  marker = value.charAt(++index);

  if (character !== $ddeaaa485da5b3088f0d01dfac5c39b5$var$C_NEWLINE || !$ddeaaa485da5b3088f0d01dfac5c39b5$var$SETEXT_MARKERS[marker]) {
    return;
  }

  subvalue += character;
  /* Eat Setext-line. */

  queue = marker;
  depth = $ddeaaa485da5b3088f0d01dfac5c39b5$var$SETEXT_MARKERS[marker];

  while (++index < length) {
    character = value.charAt(index);

    if (character !== marker) {
      if (character !== $ddeaaa485da5b3088f0d01dfac5c39b5$var$C_NEWLINE) {
        return;
      }

      index--;
      break;
    }

    queue += character;
  }

  if (silent) {
    return true;
  }

  return eat(subvalue + queue)({
    type: 'heading',
    depth: depth,
    children: self.tokenizeInline(content, now)
  });
}